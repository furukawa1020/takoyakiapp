{"$message_type":"diagnostic","message":"cannot find value `output` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2385,"byte_end":2391,"line_start":99,"line_end":99,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"            let harmony = (1.0 - (output.abs() / target)).clamp(0.0, 1.0);","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `output` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:99:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let harmony = (1.0 - (output.abs() / target)).clamp(0.0, 1.0);\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::f32::consts::PI`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":4,"byte_end":24,"line_start":1,"line_end":1,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"use std::f32::consts::PI;","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":0,"byte_end":26,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::f32::consts::PI;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::f32::consts::PI`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:1:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::f32::consts::PI;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"can't call method `clamp` on ambiguous numeric type `{float}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2409,"byte_end":2414,"line_start":99,"line_end":99,"column_start":59,"column_end":64,"is_primary":true,"text":[{"text":"            let harmony = (1.0 - (output.abs() / target)).clamp(0.0, 1.0);","highlight_start":59,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0689]\u001b[0m\u001b[1m: can't call method `clamp` on ambiguous numeric type `{float}`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:99:59\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let harmony = (1.0 - (output.abs() / target)).clamp(0.0, 1.0);\n   \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `e.game_phase` which is behind a shared reference","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8513,"byte_end":8525,"line_start":252,"line_end":252,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"    let e = unsafe { &*e }; e.game_phase as i32","highlight_start":29,"highlight_end":41}],"label":"move occurs because `e.game_phase` has type `GamePhase`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if `GamePhase` implemented `Clone`, you could clone the value","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":770,"byte_end":788,"line_start":43,"line_end":43,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub enum GamePhase {","highlight_start":1,"highlight_end":19}],"label":"consider implementing `Clone` for this type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":8513,"byte_end":8525,"line_start":252,"line_end":252,"column_start":29,"column_end":41,"is_primary":false,"text":[{"text":"    let e = unsafe { &*e }; e.game_phase as i32","highlight_start":29,"highlight_end":41}],"label":"you could clone this value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m: cannot move out of `e.game_phase` which is behind a shared reference\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:252:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m252\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let e = unsafe { &*e }; e.game_phase as i32\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because `e.game_phase` has type `GamePhase`, which does not implement the `Copy` trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if `GamePhase` implemented `Clone`, you could clone the value\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:43:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum GamePhase {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mconsider implementing `Clone` for this type\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m252\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let e = unsafe { &*e }; e.game_phase as i32\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94myou could clone this value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 3 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 3 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0425, E0507, E0689.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0425, E0507, E0689.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0425`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0425`.\u001b[0m\n"}
